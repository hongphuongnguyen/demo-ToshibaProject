; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f10x_usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\RTOS -I.\RTE\Device\STM32F103C8 -I.\RTE\_Target_1 -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\StdPeriph_Driver\inc -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F10X_MD -D_RTE_ --omf_browse=.\objects\stm32f10x_usart.crf C:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\StdPeriph_Driver\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;921      */
;;;922    void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  f4017200          AND      r2,r1,#0x200
;;;923    {
;;;924      /* Check the parameters */
;;;925      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;926      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;927      /* The CTS flag is not available for UART4 and UART5 */
;;;928      if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
000004  f5b27f00          CMP      r2,#0x200
000008  d100              BNE      |L1.12|
;;;929      {
;;;930        assert_param(IS_USART_123_PERIPH(USARTx));
00000a  bf00              NOP      
                  |L1.12|
;;;931      } 
;;;932       
;;;933      USARTx->SR = (uint16_t)~USART_FLAG;
00000c  43ca              MVNS     r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;934    }
000010  4770              BX       lr
;;;935    
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;1029     */
;;;1030   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  b510              PUSH     {r4,lr}
;;;1031   {
;;;1032     uint16_t bitpos = 0x00, itmask = 0x00;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;1033     /* Check the parameters */
;;;1034     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1035     assert_param(IS_USART_CLEAR_IT(USART_IT));
;;;1036     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1037     if (USART_IT == USART_IT_CTS)
000006  f640146a          MOV      r4,#0x96a
00000a  42a1              CMP      r1,r4
00000c  d100              BNE      |L2.16|
;;;1038     {
;;;1039       assert_param(IS_USART_123_PERIPH(USARTx));
00000e  bf00              NOP      
                  |L2.16|
;;;1040     }   
;;;1041     
;;;1042     bitpos = USART_IT >> 0x08;
000010  120a              ASRS     r2,r1,#8
;;;1043     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
000012  2401              MOVS     r4,#1
000014  4094              LSLS     r4,r4,r2
000016  b2a3              UXTH     r3,r4
;;;1044     USARTx->SR = (uint16_t)~itmask;
000018  43dc              MVNS     r4,r3
00001a  8004              STRH     r4,[r0,#0]
;;;1045   }
00001c  bd10              POP      {r4,pc}
;;;1046   /**
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;300      */
;;;301    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b510              PUSH     {r4,lr}
;;;302    {
000002  4602              MOV      r2,r0
;;;303      uint32_t tmpreg = 0x00;
000004  2000              MOVS     r0,#0
;;;304      /* Check the parameters */
;;;305      assert_param(IS_USART_123_PERIPH(USARTx));
;;;306      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;307      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;308      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;309      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;310      
;;;311    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;312      tmpreg = USARTx->CR2;
000006  8a10              LDRH     r0,[r2,#0x10]
;;;313      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;314      tmpreg &= CR2_CLOCK_CLEAR_Mask;
000008  f24f03ff          MOV      r3,#0xf0ff
00000c  4018              ANDS     r0,r0,r3
;;;315      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;316      /* Set CLKEN bit according to USART_Clock value */
;;;317      /* Set CPOL bit according to USART_CPOL value */
;;;318      /* Set CPHA bit according to USART_CPHA value */
;;;319      /* Set LBCL bit according to USART_LastBit value */
;;;320      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00000e  880b              LDRH     r3,[r1,#0]
000010  884c              LDRH     r4,[r1,#2]
000012  4323              ORRS     r3,r3,r4
000014  888c              LDRH     r4,[r1,#4]
000016  4323              ORRS     r3,r3,r4
000018  88cc              LDRH     r4,[r1,#6]
00001a  4323              ORRS     r3,r3,r4
00001c  4318              ORRS     r0,r0,r3
;;;321                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;322      /* Write to USART CR2 */
;;;323      USARTx->CR2 = (uint16_t)tmpreg;
00001e  8210              STRH     r0,[r2,#0x10]
;;;324    }
000020  bd10              POP      {r4,pc}
;;;325    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;331      */
;;;332    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;333    {
;;;334      /* USART_ClockInitStruct members default value */
;;;335      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;336      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;337      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;338      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;339    }
00000a  4770              BX       lr
;;;340    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;349      */
;;;350    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;351    {
;;;352      /* Check the parameters */
;;;353      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;354      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;355      
;;;356      if (NewState != DISABLE)
;;;357      {
;;;358        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;359        USARTx->CR1 |= CR1_UE_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f4425200          ORR      r2,r2,#0x2000
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;360      }
;;;361      else
;;;362      {
;;;363        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;364        USARTx->CR1 &= CR1_UE_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64d73ff          MOV      r3,#0xdfff
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L5.22|
;;;365      }
;;;366    }
000016  4770              BX       lr
;;;367    
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;446      */
;;;447    void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
000000  b11a              CBZ      r2,|L6.10|
;;;448    {
;;;449      /* Check the parameters */
;;;450      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;451      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;452      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;453      if (NewState != DISABLE)
;;;454      {
;;;455        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;456           DMAR bits in the USART CR3 register */
;;;457        USARTx->CR3 |= USART_DMAReq;
000002  8a83              LDRH     r3,[r0,#0x14]
000004  430b              ORRS     r3,r3,r1
000006  8283              STRH     r3,[r0,#0x14]
000008  e002              B        |L6.16|
                  |L6.10|
;;;458      }
;;;459      else
;;;460      {
;;;461        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;462           DMAR bits in the USART CR3 register */
;;;463        USARTx->CR3 &= (uint16_t)~USART_DMAReq;
00000a  8a83              LDRH     r3,[r0,#0x14]
00000c  438b              BICS     r3,r3,r1
00000e  8283              STRH     r3,[r0,#0x14]
                  |L6.16|
;;;464      }
;;;465    }
000010  4770              BX       lr
;;;466    
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;128      */
;;;129    void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;130    {
000002  4604              MOV      r4,r0
;;;131      /* Check the parameters */
;;;132      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;133    
;;;134      if (USARTx == USART1)
000004  4820              LDR      r0,|L7.136|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L7.30|
;;;135      {
;;;136        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0388              LSLS     r0,r1,#14
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;137        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f44f4080          MOV      r0,#0x4000
000018  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001c  e032              B        |L7.132|
                  |L7.30|
;;;138      }
;;;139      else if (USARTx == USART2)
00001e  481b              LDR      r0,|L7.140|
000020  4284              CMP      r4,r0
000022  d109              BNE      |L7.56|
;;;140      {
;;;141        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000024  2101              MOVS     r1,#1
000026  0448              LSLS     r0,r1,#17
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;142        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
00002c  2100              MOVS     r1,#0
00002e  f44f3000          MOV      r0,#0x20000
000032  f7fffffe          BL       RCC_APB1PeriphResetCmd
000036  e025              B        |L7.132|
                  |L7.56|
;;;143      }
;;;144      else if (USARTx == USART3)
000038  4815              LDR      r0,|L7.144|
00003a  4284              CMP      r4,r0
00003c  d109              BNE      |L7.82|
;;;145      {
;;;146        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
00003e  2101              MOVS     r1,#1
000040  0488              LSLS     r0,r1,#18
000042  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;147        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000046  2100              MOVS     r1,#0
000048  f44f2080          MOV      r0,#0x40000
00004c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000050  e018              B        |L7.132|
                  |L7.82|
;;;148      }    
;;;149      else if (USARTx == UART4)
000052  4810              LDR      r0,|L7.148|
000054  4284              CMP      r4,r0
000056  d109              BNE      |L7.108|
;;;150      {
;;;151        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000058  2101              MOVS     r1,#1
00005a  04c8              LSLS     r0,r1,#19
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;152        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
000060  2100              MOVS     r1,#0
000062  f44f2000          MOV      r0,#0x80000
000066  f7fffffe          BL       RCC_APB1PeriphResetCmd
00006a  e00b              B        |L7.132|
                  |L7.108|
;;;153      }    
;;;154      else
;;;155      {
;;;156        if (USARTx == UART5)
00006c  480a              LDR      r0,|L7.152|
00006e  4284              CMP      r4,r0
000070  d108              BNE      |L7.132|
;;;157        { 
;;;158          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000072  2101              MOVS     r1,#1
000074  0508              LSLS     r0,r1,#20
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;159          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
00007a  2100              MOVS     r1,#0
00007c  f44f1080          MOV      r0,#0x100000
000080  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L7.132|
;;;160        }
;;;161      }
;;;162    }
000084  bd10              POP      {r4,pc}
;;;163    
                          ENDP

000086  0000              DCW      0x0000
                  |L7.136|
                          DCD      0x40013800
                  |L7.140|
                          DCD      0x40004400
                  |L7.144|
                          DCD      0x40004800
                  |L7.148|
                          DCD      0x40004c00
                  |L7.152|
                          DCD      0x40005000

                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;872      */
;;;873    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  4602              MOV      r2,r0
;;;874    {
;;;875      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;876      /* Check the parameters */
;;;877      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;878      assert_param(IS_USART_FLAG(USART_FLAG));
;;;879      /* The CTS flag is not available for UART4 and UART5 */
;;;880      if (USART_FLAG == USART_FLAG_CTS)
000004  f5b17f00          CMP      r1,#0x200
000008  d100              BNE      |L8.12|
;;;881      {
;;;882        assert_param(IS_USART_123_PERIPH(USARTx));
00000a  bf00              NOP      
                  |L8.12|
;;;883      }  
;;;884      
;;;885      if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
00000c  8813              LDRH     r3,[r2,#0]
00000e  400b              ANDS     r3,r3,r1
000010  b10b              CBZ      r3,|L8.22|
;;;886      {
;;;887        bitstatus = SET;
000012  2001              MOVS     r0,#1
000014  e000              B        |L8.24|
                  |L8.22|
;;;888      }
;;;889      else
;;;890      {
;;;891        bitstatus = RESET;
000016  2000              MOVS     r0,#0
                  |L8.24|
;;;892      }
;;;893      return bitstatus;
;;;894    }
000018  4770              BX       lr
;;;895    
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;955      */
;;;956    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;957    {
000002  4602              MOV      r2,r0
;;;958      uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
000004  2400              MOVS     r4,#0
000006  2300              MOVS     r3,#0
000008  2500              MOVS     r5,#0
;;;959      ITStatus bitstatus = RESET;
00000a  2000              MOVS     r0,#0
;;;960      /* Check the parameters */
;;;961      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;962      assert_param(IS_USART_GET_IT(USART_IT));
;;;963      /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;964      if (USART_IT == USART_IT_CTS)
00000c  f640166a          MOV      r6,#0x96a
000010  42b1              CMP      r1,r6
000012  d100              BNE      |L9.22|
;;;965      {
;;;966        assert_param(IS_USART_123_PERIPH(USARTx));
000014  bf00              NOP      
                  |L9.22|
;;;967      }   
;;;968      
;;;969      /* Get the USART register index */
;;;970      usartreg = (((uint8_t)USART_IT) >> 0x05);
000016  f3c11542          UBFX     r5,r1,#5,#3
;;;971      /* Get the interrupt position */
;;;972      itmask = USART_IT & IT_Mask;
00001a  f001031f          AND      r3,r1,#0x1f
;;;973      itmask = (uint32_t)0x01 << itmask;
00001e  2601              MOVS     r6,#1
000020  fa06f303          LSL      r3,r6,r3
;;;974      
;;;975      if (usartreg == 0x01) /* The IT  is in CR1 register */
000024  2d01              CMP      r5,#1
000026  d102              BNE      |L9.46|
;;;976      {
;;;977        itmask &= USARTx->CR1;
000028  8996              LDRH     r6,[r2,#0xc]
00002a  4033              ANDS     r3,r3,r6
00002c  e006              B        |L9.60|
                  |L9.46|
;;;978      }
;;;979      else if (usartreg == 0x02) /* The IT  is in CR2 register */
00002e  2d02              CMP      r5,#2
000030  d102              BNE      |L9.56|
;;;980      {
;;;981        itmask &= USARTx->CR2;
000032  8a16              LDRH     r6,[r2,#0x10]
000034  4033              ANDS     r3,r3,r6
000036  e001              B        |L9.60|
                  |L9.56|
;;;982      }
;;;983      else /* The IT  is in CR3 register */
;;;984      {
;;;985        itmask &= USARTx->CR3;
000038  8a96              LDRH     r6,[r2,#0x14]
00003a  4033              ANDS     r3,r3,r6
                  |L9.60|
;;;986      }
;;;987      
;;;988      bitpos = USART_IT >> 0x08;
00003c  120c              ASRS     r4,r1,#8
;;;989      bitpos = (uint32_t)0x01 << bitpos;
00003e  2601              MOVS     r6,#1
000040  fa06f404          LSL      r4,r6,r4
;;;990      bitpos &= USARTx->SR;
000044  8816              LDRH     r6,[r2,#0]
000046  4034              ANDS     r4,r4,r6
;;;991      if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
000048  b113              CBZ      r3,|L9.80|
00004a  b10c              CBZ      r4,|L9.80|
;;;992      {
;;;993        bitstatus = SET;
00004c  2001              MOVS     r0,#1
00004e  e000              B        |L9.82|
                  |L9.80|
;;;994      }
;;;995      else
;;;996      {
;;;997        bitstatus = RESET;
000050  2000              MOVS     r0,#0
                  |L9.82|
;;;998      }
;;;999      
;;;1000     return bitstatus;  
;;;1001   }
000052  bd70              POP      {r4-r6,pc}
;;;1002   
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;729      */
;;;730    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L10.12|
;;;731    {
;;;732      /* Check the parameters */
;;;733      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;734      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;735      
;;;736      if (NewState != DISABLE)
;;;737      {
;;;738        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;739        USARTx->CR3 |= CR3_HDSEL_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420208          ORR      r2,r2,#8
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L10.22|
                  |L10.12|
;;;740      }
;;;741      else
;;;742      {
;;;743        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;744        USARTx->CR3 &= CR3_HDSEL_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L10.22|
;;;745      }
;;;746    }
000016  4770              BX       lr
;;;747    
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;386      */
;;;387    void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000000  b5f0              PUSH     {r4-r7,lr}
;;;388    {
000002  4603              MOV      r3,r0
;;;389      uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
000004  2400              MOVS     r4,#0
000006  2600              MOVS     r6,#0
000008  2500              MOVS     r5,#0
;;;390      uint32_t usartxbase = 0x00;
00000a  2000              MOVS     r0,#0
;;;391      /* Check the parameters */
;;;392      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;393      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;394      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;395      /* The CTS interrupt is not available for UART4 and UART5 */
;;;396      if (USART_IT == USART_IT_CTS)
00000c  f640176a          MOV      r7,#0x96a
000010  42b9              CMP      r1,r7
000012  d100              BNE      |L11.22|
;;;397      {
;;;398        assert_param(IS_USART_123_PERIPH(USARTx));
000014  bf00              NOP      
                  |L11.22|
;;;399      }   
;;;400      
;;;401      usartxbase = (uint32_t)USARTx;
000016  4618              MOV      r0,r3
;;;402    
;;;403      /* Get the USART register index */
;;;404      usartreg = (((uint8_t)USART_IT) >> 0x05);
000018  f3c11442          UBFX     r4,r1,#5,#3
;;;405    
;;;406      /* Get the interrupt position */
;;;407      itpos = USART_IT & IT_Mask;
00001c  f001061f          AND      r6,r1,#0x1f
;;;408      itmask = (((uint32_t)0x01) << itpos);
000020  2701              MOVS     r7,#1
000022  fa07f506          LSL      r5,r7,r6
;;;409        
;;;410      if (usartreg == 0x01) /* The IT is in CR1 register */
000026  2c01              CMP      r4,#1
000028  d101              BNE      |L11.46|
;;;411      {
;;;412        usartxbase += 0x0C;
00002a  300c              ADDS     r0,r0,#0xc
00002c  e004              B        |L11.56|
                  |L11.46|
;;;413      }
;;;414      else if (usartreg == 0x02) /* The IT is in CR2 register */
00002e  2c02              CMP      r4,#2
000030  d101              BNE      |L11.54|
;;;415      {
;;;416        usartxbase += 0x10;
000032  3010              ADDS     r0,r0,#0x10
000034  e000              B        |L11.56|
                  |L11.54|
;;;417      }
;;;418      else /* The IT is in CR3 register */
;;;419      {
;;;420        usartxbase += 0x14; 
000036  3014              ADDS     r0,r0,#0x14
                  |L11.56|
;;;421      }
;;;422      if (NewState != DISABLE)
000038  b11a              CBZ      r2,|L11.66|
;;;423      {
;;;424        *(__IO uint32_t*)usartxbase  |= itmask;
00003a  6807              LDR      r7,[r0,#0]
00003c  432f              ORRS     r7,r7,r5
00003e  6007              STR      r7,[r0,#0]
000040  e002              B        |L11.72|
                  |L11.66|
;;;425      }
;;;426      else
;;;427      {
;;;428        *(__IO uint32_t*)usartxbase &= ~itmask;
000042  6807              LDR      r7,[r0,#0]
000044  43af              BICS     r7,r7,r5
000046  6007              STR      r7,[r0,#0]
                  |L11.72|
;;;429      }
;;;430    }
000048  bdf0              POP      {r4-r7,pc}
;;;431    
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;174      */
;;;175    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;176    {
000004  b086              SUB      sp,sp,#0x18
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
;;;177      uint32_t tmpreg = 0x00, apbclock = 0x00;
00000a  2400              MOVS     r4,#0
00000c  46a2              MOV      r10,r4
;;;178      uint32_t integerdivider = 0x00;
00000e  bf00              NOP      
;;;179      uint32_t fractionaldivider = 0x00;
000010  46a1              MOV      r9,r4
;;;180      uint32_t usartxbase = 0;
000012  2700              MOVS     r7,#0
;;;181      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;182      /* Check the parameters */
;;;183      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;184      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;185      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;186      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;187      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;188      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;189      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;190      /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;191      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
000014  89b0              LDRH     r0,[r6,#0xc]
000016  b100              CBZ      r0,|L12.26|
;;;192      {
;;;193        assert_param(IS_USART_123_PERIPH(USARTx));
000018  bf00              NOP      
                  |L12.26|
;;;194      }
;;;195    
;;;196      usartxbase = (uint32_t)USARTx;
00001a  462f              MOV      r7,r5
;;;197    
;;;198    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;199      tmpreg = USARTx->CR2;
00001c  8a2c              LDRH     r4,[r5,#0x10]
;;;200      /* Clear STOP[13:12] bits */
;;;201      tmpreg &= CR2_STOP_CLEAR_Mask;
00001e  f64c70ff          MOV      r0,#0xcfff
000022  4004              ANDS     r4,r4,r0
;;;202      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;203      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;204      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
000024  88f0              LDRH     r0,[r6,#6]
000026  4304              ORRS     r4,r4,r0
;;;205      
;;;206      /* Write to USART CR2 */
;;;207      USARTx->CR2 = (uint16_t)tmpreg;
000028  822c              STRH     r4,[r5,#0x10]
;;;208    
;;;209    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;210      tmpreg = USARTx->CR1;
00002a  89ac              LDRH     r4,[r5,#0xc]
;;;211      /* Clear M, PCE, PS, TE and RE bits */
;;;212      tmpreg &= CR1_CLEAR_Mask;
00002c  f64e10f3          MOV      r0,#0xe9f3
000030  4004              ANDS     r4,r4,r0
;;;213      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;214      /* Set the M bits according to USART_WordLength value */
;;;215      /* Set PCE and PS bits according to USART_Parity value */
;;;216      /* Set TE and RE bits according to USART_Mode value */
;;;217      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
000032  88b0              LDRH     r0,[r6,#4]
000034  8931              LDRH     r1,[r6,#8]
000036  4308              ORRS     r0,r0,r1
000038  8971              LDRH     r1,[r6,#0xa]
00003a  4308              ORRS     r0,r0,r1
00003c  4304              ORRS     r4,r4,r0
;;;218                USART_InitStruct->USART_Mode;
;;;219      /* Write to USART CR1 */
;;;220      USARTx->CR1 = (uint16_t)tmpreg;
00003e  81ac              STRH     r4,[r5,#0xc]
;;;221    
;;;222    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;223      tmpreg = USARTx->CR3;
000040  8aac              LDRH     r4,[r5,#0x14]
;;;224      /* Clear CTSE and RTSE bits */
;;;225      tmpreg &= CR3_CLEAR_Mask;
000042  f64f40ff          MOV      r0,#0xfcff
000046  4004              ANDS     r4,r4,r0
;;;226      /* Configure the USART HFC -------------------------------------------------*/
;;;227      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;228      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000048  89b0              LDRH     r0,[r6,#0xc]
00004a  4304              ORRS     r4,r4,r0
;;;229      /* Write to USART CR3 */
;;;230      USARTx->CR3 = (uint16_t)tmpreg;
00004c  82ac              STRH     r4,[r5,#0x14]
;;;231    
;;;232    /*---------------------------- USART BRR Configuration -----------------------*/
;;;233      /* Configure the USART Baud Rate -------------------------------------------*/
;;;234      RCC_GetClocksFreq(&RCC_ClocksStatus);
00004e  a801              ADD      r0,sp,#4
000050  f7fffffe          BL       RCC_GetClocksFreq
;;;235      if (usartxbase == USART1_BASE)
000054  481f              LDR      r0,|L12.212|
000056  4287              CMP      r7,r0
000058  d102              BNE      |L12.96|
;;;236      {
;;;237        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
00005a  f8dda010          LDR      r10,[sp,#0x10]
00005e  e001              B        |L12.100|
                  |L12.96|
;;;238      }
;;;239      else
;;;240      {
;;;241        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
000060  f8dda00c          LDR      r10,[sp,#0xc]
                  |L12.100|
;;;242      }
;;;243      
;;;244      /* Determine the integer part */
;;;245      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
000064  89a8              LDRH     r0,[r5,#0xc]
000066  f4004000          AND      r0,r0,#0x8000
00006a  b140              CBZ      r0,|L12.126|
;;;246      {
;;;247        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;248        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
00006c  eb0a00ca          ADD      r0,r10,r10,LSL #3
000070  eb00100a          ADD      r0,r0,r10,LSL #4
000074  6831              LDR      r1,[r6,#0]
000076  0049              LSLS     r1,r1,#1
000078  fbb0f8f1          UDIV     r8,r0,r1
00007c  e007              B        |L12.142|
                  |L12.126|
;;;249      }
;;;250      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;251      {
;;;252        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;253        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
00007e  eb0a00ca          ADD      r0,r10,r10,LSL #3
000082  eb00100a          ADD      r0,r0,r10,LSL #4
000086  6831              LDR      r1,[r6,#0]
000088  0089              LSLS     r1,r1,#2
00008a  fbb0f8f1          UDIV     r8,r0,r1
                  |L12.142|
;;;254      }
;;;255      tmpreg = (integerdivider / 100) << 4;
00008e  2064              MOVS     r0,#0x64
000090  fbb8f0f0          UDIV     r0,r8,r0
000094  0104              LSLS     r4,r0,#4
;;;256    
;;;257      /* Determine the fractional part */
;;;258      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
000096  0920              LSRS     r0,r4,#4
000098  2164              MOVS     r1,#0x64
00009a  fb018910          MLS      r9,r1,r0,r8
;;;259    
;;;260      /* Implement the fractional part in the register */
;;;261      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
00009e  89a8              LDRH     r0,[r5,#0xc]
0000a0  f4004000          AND      r0,r0,#0x8000
0000a4  b140              CBZ      r0,|L12.184|
;;;262      {
;;;263        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
0000a6  2032              MOVS     r0,#0x32
0000a8  eb0000c9          ADD      r0,r0,r9,LSL #3
0000ac  fbb0f0f1          UDIV     r0,r0,r1
0000b0  f0000007          AND      r0,r0,#7
0000b4  4304              ORRS     r4,r4,r0
0000b6  e008              B        |L12.202|
                  |L12.184|
;;;264      }
;;;265      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;266      {
;;;267        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
0000b8  2032              MOVS     r0,#0x32
0000ba  eb001009          ADD      r0,r0,r9,LSL #4
0000be  2164              MOVS     r1,#0x64
0000c0  fbb0f0f1          UDIV     r0,r0,r1
0000c4  f000000f          AND      r0,r0,#0xf
0000c8  4304              ORRS     r4,r4,r0
                  |L12.202|
;;;268      }
;;;269      
;;;270      /* Write to USART BRR */
;;;271      USARTx->BRR = (uint16_t)tmpreg;
0000ca  812c              STRH     r4,[r5,#8]
;;;272    }
0000cc  b006              ADD      sp,sp,#0x18
0000ce  e8bd87f0          POP      {r4-r10,pc}
;;;273    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L12.212|
                          DCD      0x40013800

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=1

                  USART_IrDACmd PROC
;;;835      */
;;;836    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;837    {
;;;838      /* Check the parameters */
;;;839      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;840      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;841        
;;;842      if (NewState != DISABLE)
;;;843      {
;;;844        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;845        USARTx->CR3 |= CR3_IREN_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420202          ORR      r2,r2,#2
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L13.22|
                  |L13.12|
;;;846      }
;;;847      else
;;;848      {
;;;849        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;850        USARTx->CR3 &= CR3_IREN_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L13.22|
;;;851      }
;;;852    }
000016  4770              BX       lr
;;;853    
                          ENDP


                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  USART_IrDAConfig PROC
;;;816      */
;;;817    void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
000000  8a82              LDRH     r2,[r0,#0x14]
;;;818    {
;;;819      /* Check the parameters */
;;;820      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;821      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;822        
;;;823      USARTx->CR3 &= CR3_IRLP_Mask;
000002  f64f73fb          MOV      r3,#0xfffb
000006  401a              ANDS     r2,r2,r3
000008  8282              STRH     r2,[r0,#0x14]
;;;824      USARTx->CR3 |= USART_IrDAMode;
00000a  8a82              LDRH     r2,[r0,#0x14]
00000c  430a              ORRS     r2,r2,r1
00000e  8282              STRH     r2,[r0,#0x14]
;;;825    }
000010  4770              BX       lr
;;;826    
                          ENDP


                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=1

                  USART_LINBreakDetectLengthConfig PROC
;;;545      */
;;;546    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;547    {
;;;548      /* Check the parameters */
;;;549      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;550      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;551      
;;;552      USARTx->CR2 &= CR2_LBDL_Mask;
000002  f64f73df          MOV      r3,#0xffdf
000006  401a              ANDS     r2,r2,r3
000008  8202              STRH     r2,[r0,#0x10]
;;;553      USARTx->CR2 |= USART_LINBreakDetectLength;  
00000a  8a02              LDRH     r2,[r0,#0x10]
00000c  430a              ORRS     r2,r2,r1
00000e  8202              STRH     r2,[r0,#0x10]
;;;554    }
000010  4770              BX       lr
;;;555    
                          ENDP


                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=1

                  USART_LINCmd PROC
;;;564      */
;;;565    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L16.12|
;;;566    {
;;;567      /* Check the parameters */
;;;568      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;569      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;570      
;;;571      if (NewState != DISABLE)
;;;572      {
;;;573        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;574        USARTx->CR2 |= CR2_LINEN_Set;
000002  8a02              LDRH     r2,[r0,#0x10]
000004  f4424280          ORR      r2,r2,#0x4000
000008  8202              STRH     r2,[r0,#0x10]
00000a  e004              B        |L16.22|
                  |L16.12|
;;;575      }
;;;576      else
;;;577      {
;;;578        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;579        USARTx->CR2 &= CR2_LINEN_Reset;
00000c  8a02              LDRH     r2,[r0,#0x10]
00000e  f64b73ff          MOV      r3,#0xbfff
000012  401a              ANDS     r2,r2,r3
000014  8202              STRH     r2,[r0,#0x10]
                  |L16.22|
;;;580      }
;;;581    }
000016  4770              BX       lr
;;;582    
                          ENDP


                          AREA ||i.USART_OneBitMethodCmd||, CODE, READONLY, ALIGN=1

                  USART_OneBitMethodCmd PROC
;;;787      */
;;;788    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;789    {
;;;790      /* Check the parameters */
;;;791      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;792      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;793      
;;;794      if (NewState != DISABLE)
;;;795      {
;;;796        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;797        USARTx->CR3 |= CR3_ONEBITE_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f4426200          ORR      r2,r2,#0x800
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L17.22|
                  |L17.12|
;;;798      }
;;;799      else
;;;800      {
;;;801        /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
;;;802        USARTx->CR3 &= CR3_ONEBITE_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f24f73ff          MOV      r3,#0xf7ff
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L17.22|
;;;803      }
;;;804    }
000016  4770              BX       lr
;;;805    
                          ENDP


                          AREA ||i.USART_OverSampling8Cmd||, CODE, READONLY, ALIGN=1

                  USART_OverSampling8Cmd PROC
;;;760      */
;;;761    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L18.12|
;;;762    {
;;;763      /* Check the parameters */
;;;764      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;765      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;766      
;;;767      if (NewState != DISABLE)
;;;768      {
;;;769        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;770        USARTx->CR1 |= CR1_OVER8_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f4424200          ORR      r2,r2,#0x8000
000008  8182              STRH     r2,[r0,#0xc]
00000a  e003              B        |L18.20|
                  |L18.12|
;;;771      }
;;;772      else
;;;773      {
;;;774        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;775        USARTx->CR1 &= CR1_OVER8_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f3c2020e          UBFX     r2,r2,#0,#15
000012  8182              STRH     r2,[r0,#0xc]
                  |L18.20|
;;;776      }
;;;777    }
000014  4770              BX       lr
;;;778    
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;607      */
;;;608    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  4601              MOV      r1,r0
;;;609    {
;;;610      /* Check the parameters */
;;;611      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;612      
;;;613      /* Receive Data */
;;;614      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000002  8888              LDRH     r0,[r1,#4]
000004  f3c00008          UBFX     r0,r0,#0,#9
;;;615    }
000008  4770              BX       lr
;;;616    
                          ENDP


                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverWakeUpCmd PROC
;;;516      */
;;;517    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L20.12|
;;;518    {
;;;519      /* Check the parameters */
;;;520      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;521      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;522      
;;;523      if (NewState != DISABLE)
;;;524      {
;;;525        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;526        USARTx->CR1 |= CR1_RWU_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f0420202          ORR      r2,r2,#2
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L20.22|
                  |L20.12|
;;;527      }
;;;528      else
;;;529      {
;;;530        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;531        USARTx->CR1 &= CR1_RWU_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L20.22|
;;;532      }
;;;533    }
000016  4770              BX       lr
;;;534    
                          ENDP


                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=1

                  USART_SendBreak PROC
;;;623      */
;;;624    void USART_SendBreak(USART_TypeDef* USARTx)
000000  8981              LDRH     r1,[r0,#0xc]
;;;625    {
;;;626      /* Check the parameters */
;;;627      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;628      
;;;629      /* Send break characters */
;;;630      USARTx->CR1 |= CR1_SBK_Set;
000002  f0410101          ORR      r1,r1,#1
000006  8181              STRH     r1,[r0,#0xc]
;;;631    }
000008  4770              BX       lr
;;;632    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;590      */
;;;591    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  f3c10208          UBFX     r2,r1,#0,#9
;;;592    {
;;;593      /* Check the parameters */
;;;594      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;595      assert_param(IS_USART_DATA(Data)); 
;;;596        
;;;597      /* Transmit Data */
;;;598      USARTx->DR = (Data & (uint16_t)0x01FF);
000004  8082              STRH     r2,[r0,#4]
;;;599    }
000006  4770              BX       lr
;;;600    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;474      */
;;;475    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;476    {
;;;477      /* Check the parameters */
;;;478      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;479      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;480        
;;;481      /* Clear the USART address */
;;;482      USARTx->CR2 &= CR2_Address_Mask;
000002  f64f73f0          MOV      r3,#0xfff0
000006  401a              ANDS     r2,r2,r3
000008  8202              STRH     r2,[r0,#0x10]
;;;483      /* Set the USART address node */
;;;484      USARTx->CR2 |= USART_Address;
00000a  8a02              LDRH     r2,[r0,#0x10]
00000c  430a              ORRS     r2,r2,r1
00000e  8202              STRH     r2,[r0,#0x10]
;;;485    }
000010  4770              BX       lr
;;;486    
                          ENDP


                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=1

                  USART_SetGuardTime PROC
;;;639      */
;;;640    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;641    {    
;;;642      /* Check the parameters */
;;;643      assert_param(IS_USART_123_PERIPH(USARTx));
;;;644      
;;;645      /* Clear the USART Guard time */
;;;646      USARTx->GTPR &= GTPR_LSB_Mask;
000002  b2d2              UXTB     r2,r2
000004  8302              STRH     r2,[r0,#0x18]
;;;647      /* Set the USART guard time */
;;;648      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
000006  8b02              LDRH     r2,[r0,#0x18]
000008  ea422201          ORR      r2,r2,r1,LSL #8
00000c  8302              STRH     r2,[r0,#0x18]
;;;649    }
00000e  4770              BX       lr
;;;650    
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;659      */
;;;660    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;661    { 
;;;662      /* Check the parameters */
;;;663      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;664      
;;;665      /* Clear the USART prescaler */
;;;666      USARTx->GTPR &= GTPR_MSB_Mask;
000002  f402427f          AND      r2,r2,#0xff00
000006  8302              STRH     r2,[r0,#0x18]
;;;667      /* Set the USART prescaler */
;;;668      USARTx->GTPR |= USART_Prescaler;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;669    }
00000e  4770              BX       lr
;;;670    
                          ENDP


                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardCmd PROC
;;;678      */
;;;679    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L26.12|
;;;680    {
;;;681      /* Check the parameters */
;;;682      assert_param(IS_USART_123_PERIPH(USARTx));
;;;683      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;684      if (NewState != DISABLE)
;;;685      {
;;;686        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;687        USARTx->CR3 |= CR3_SCEN_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420220          ORR      r2,r2,#0x20
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L26.22|
                  |L26.12|
;;;688      }
;;;689      else
;;;690      {
;;;691        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;692        USARTx->CR3 &= CR3_SCEN_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73df          MOV      r3,#0xffdf
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L26.22|
;;;693      }
;;;694    }
000016  4770              BX       lr
;;;695    
                          ENDP


                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACKCmd PROC
;;;703      */
;;;704    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L27.12|
;;;705    {
;;;706      /* Check the parameters */
;;;707      assert_param(IS_USART_123_PERIPH(USARTx));  
;;;708      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;709      if (NewState != DISABLE)
;;;710      {
;;;711        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;712        USARTx->CR3 |= CR3_NACK_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420210          ORR      r2,r2,#0x10
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L27.22|
                  |L27.12|
;;;713      }
;;;714      else
;;;715      {
;;;716        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;717        USARTx->CR3 &= CR3_NACK_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73ef          MOV      r3,#0xffef
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L27.22|
;;;718      }
;;;719    }
000016  4770              BX       lr
;;;720    
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;279      */
;;;280    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;281    {
;;;282      /* USART_InitStruct members default value */
;;;283      USART_InitStruct->USART_BaudRate = 9600;
000004  6001              STR      r1,[r0,#0]
;;;284      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;285      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;286      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;287      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  210c              MOVS     r1,#0xc
000010  8141              STRH     r1,[r0,#0xa]
;;;288      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  2100              MOVS     r1,#0
000014  8181              STRH     r1,[r0,#0xc]
;;;289    }
000016  4770              BX       lr
;;;290    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_WakeUpConfig PROC
;;;497      */
;;;498    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000000  8982              LDRH     r2,[r0,#0xc]
;;;499    {
;;;500      /* Check the parameters */
;;;501      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;502      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;503      
;;;504      USARTx->CR1 &= CR1_WAKE_Mask;
000002  f24f73ff          MOV      r3,#0xf7ff
000006  401a              ANDS     r2,r2,r3
000008  8182              STRH     r2,[r0,#0xc]
;;;505      USARTx->CR1 |= USART_WakeUp;
00000a  8982              LDRH     r2,[r0,#0xc]
00000c  430a              ORRS     r2,r2,r1
00000e  8182              STRH     r2,[r0,#0xc]
;;;506    }
000010  4770              BX       lr
;;;507    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Users\\Admin\\AppData\\Local\\Arm\\Packs\\Keil\\STM32F1xx_DFP\\2.4.1\\Device\\StdPeriph_Driver\\src\\stm32f10x_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f10x_usart_c_9565154b____REV16|
#line 208 "C:\\Users\\Admin\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___17_stm32f10x_usart_c_9565154b____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f10x_usart_c_9565154b____REVSH|
#line 223
|__asm___17_stm32f10x_usart_c_9565154b____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f10x_usart_c_9565154b____RRX|
#line 410
|__asm___17_stm32f10x_usart_c_9565154b____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
