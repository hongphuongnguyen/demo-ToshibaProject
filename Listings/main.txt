; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\main.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\RTOS -I.\RTE\Device\STM32F103C8 -I.\RTE\_Target_1 -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\StdPeriph_Driver\inc -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F10X_MD -D_RTE_ --omf_browse=.\objects\main.crf main.c]
                          THUMB

                          AREA ||i.Handle_Command||, CODE, READONLY, ALIGN=2

                  Handle_Command PROC
;;;107    
;;;108    void Handle_Command(ULONG thread_input) {   
000000  e034              B        |L1.108|
                  |L1.2|
;;;109    		while(1) {
;;;110    				switch (status) {
000002  481b              LDR      r0,|L1.112|
000004  6800              LDR      r0,[r0,#0]  ; status
000006  2807              CMP      r0,#7
000008  d22b              BCS      |L1.98|
00000a  e8dff000          TBB      [pc,r0]
00000e  2a04              DCB      0x2a,0x04
000010  0a10161c          DCB      0x0a,0x10,0x16,0x1c
000014  2300              DCB      0x23,0x00
;;;111    						case 1:
;;;112    								Turn_On_Led_13();
000016  f7fffffe          BL       Turn_On_Led_13
;;;113    								status=0;
00001a  2000              MOVS     r0,#0
00001c  4914              LDR      r1,|L1.112|
00001e  6008              STR      r0,[r1,#0]  ; status
;;;114    								break;
000020  e020              B        |L1.100|
;;;115    						case 2:
;;;116    								Turn_Off_Led_13();
000022  f7fffffe          BL       Turn_Off_Led_13
;;;117    								status=0;
000026  2000              MOVS     r0,#0
000028  4911              LDR      r1,|L1.112|
00002a  6008              STR      r0,[r1,#0]  ; status
;;;118    								break;
00002c  e01a              B        |L1.100|
;;;119    						case 3:
;;;120    								Turn_On_Led_14();
00002e  f7fffffe          BL       Turn_On_Led_14
;;;121    								status=0;
000032  2000              MOVS     r0,#0
000034  490e              LDR      r1,|L1.112|
000036  6008              STR      r0,[r1,#0]  ; status
;;;122    								break;
000038  e014              B        |L1.100|
;;;123    						case 4:
;;;124    								Turn_Off_Led_14();
00003a  f7fffffe          BL       Turn_Off_Led_14
;;;125    								status=0;
00003e  2000              MOVS     r0,#0
000040  490b              LDR      r1,|L1.112|
000042  6008              STR      r0,[r1,#0]  ; status
;;;126    								break;
000044  e00e              B        |L1.100|
;;;127    						case 5:
;;;128    								Usart_Send_Line(UNKNOWN_COMMAND);
000046  a00b              ADR      r0,|L1.116|
000048  f7fffffe          BL       Usart_Send_Line
;;;129    								status=0;
00004c  2000              MOVS     r0,#0
00004e  4908              LDR      r1,|L1.112|
000050  6008              STR      r0,[r1,#0]  ; status
;;;130    								break;
000052  e007              B        |L1.100|
;;;131    						case 6:
;;;132    								Usart_Send_Line(COMMAND_TOO_LONG);
000054  a00b              ADR      r0,|L1.132|
000056  f7fffffe          BL       Usart_Send_Line
;;;133    								status=0;
00005a  2000              MOVS     r0,#0
00005c  4904              LDR      r1,|L1.112|
00005e  6008              STR      r0,[r1,#0]  ; status
;;;134    								break;	
000060  e000              B        |L1.100|
                  |L1.98|
;;;135    						default: 
;;;136    								break;					
000062  bf00              NOP      
                  |L1.100|
000064  bf00              NOP                            ;114
;;;137    				}
;;;138    				tx_thread_sleep(1);
000066  2001              MOVS     r0,#1
000068  f7fffffe          BL       _tx_thread_sleep
                  |L1.108|
00006c  e7c9              B        |L1.2|
;;;139    		}
;;;140    }
;;;141    
                          ENDP

00006e  0000              DCW      0x0000
                  |L1.112|
                          DCD      status
                  |L1.116|
000074  756e6b6e          DCB      "unknown command",0
000078  6f776e20
00007c  636f6d6d
000080  616e6400
                  |L1.132|
000084  636f6d6d          DCB      "command too long",0
000088  616e6420
00008c  746f6f20
000090  6c6f6e67
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0

                          AREA ||i.Init_Output||, CODE, READONLY, ALIGN=2

                  Init_Output PROC
;;;15     
;;;16     void Init_Output(void) {
000000  b508              PUSH     {r3,lr}
;;;17         /* GPIO structure for port initialization */
;;;18         GPIO_InitTypeDef GPIO_Settings;
;;;19     
;;;20         /* Enable clock on APB2 */
;;;21         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;22     
;;;23         /* Configure port A1 for driving an LED 13*/
;;;24         GPIO_Settings.GPIO_Pin = GPIO_Pin_13;
00000a  f44f5000          MOV      r0,#0x2000
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;25         GPIO_Settings.GPIO_Mode = GPIO_Mode_Out_PP;    /* Output push-pull mode */
000012  2010              MOVS     r0,#0x10
000014  f88d0003          STRB     r0,[sp,#3]
;;;26         GPIO_Settings.GPIO_Speed = GPIO_Speed_50MHz;   /* Highest speed */
000018  2003              MOVS     r0,#3
00001a  f88d0002          STRB     r0,[sp,#2]
;;;27         GPIO_Init(GPIOC, &GPIO_Settings) ;             /* Initialize port */
00001e  4669              MOV      r1,sp
000020  4808              LDR      r0,|L2.68|
000022  f7fffffe          BL       GPIO_Init
;;;28     	
;;;29     		/* Configure port A1 for driving an LED 14*/
;;;30         GPIO_Settings.GPIO_Pin = GPIO_Pin_14;
000026  f44f4080          MOV      r0,#0x4000
00002a  f8ad0000          STRH     r0,[sp,#0]
;;;31         GPIO_Settings.GPIO_Mode = GPIO_Mode_Out_PP;    /* Output push-pull mode */
00002e  2010              MOVS     r0,#0x10
000030  f88d0003          STRB     r0,[sp,#3]
;;;32         GPIO_Settings.GPIO_Speed = GPIO_Speed_50MHz;   /* Highest speed */
000034  2003              MOVS     r0,#3
000036  f88d0002          STRB     r0,[sp,#2]
;;;33         GPIO_Init(GPIOC, &GPIO_Settings) ;             /* Initialize port */
00003a  4669              MOV      r1,sp
00003c  4801              LDR      r0,|L2.68|
00003e  f7fffffe          BL       GPIO_Init
;;;34     }
000042  bd08              POP      {r3,pc}
;;;35     
                          ENDP

                  |L2.68|
                          DCD      0x40011000

                          AREA ||i.Receive_Commmand||, CODE, READONLY, ALIGN=2

                  Receive_Commmand PROC
;;;141    
;;;142    void Receive_Commmand(ULONG thread_input) { 
000000  2500              MOVS     r5,#0
;;;143    		unsigned short usart_buf_length=0;
;;;144    		unsigned char received;
;;;145        while(1) {
000002  e04f              B        |L3.164|
                  |L3.4|
;;;146            if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
000004  f2405125          MOV      r1,#0x525
000008  4827              LDR      r0,|L3.168|
00000a  f7fffffe          BL       USART_GetITStatus
00000e  2800              CMP      r0,#0
000010  d045              BEQ      |L3.158|
;;;147    						received = USART_ReceiveData(USART1);
000012  4825              LDR      r0,|L3.168|
000014  f7fffffe          BL       USART_ReceiveData
000018  b2c4              UXTB     r4,r0
;;;148    						/* Check commmand */
;;;149    						if (usart_buf_length < COMMAND_MAX_LENGTH) {
00001a  2d0f              CMP      r5,#0xf
00001c  da07              BGE      |L3.46|
;;;150    								usart_buf[usart_buf_length++] = received;
00001e  4628              MOV      r0,r5
000020  1c69              ADDS     r1,r5,#1
000022  b28d              UXTH     r5,r1
000024  4921              LDR      r1,|L3.172|
000026  540c              STRB     r4,[r1,r0]
;;;151    								Usart_Send(received);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       Usart_Send
                  |L3.46|
;;;152    						}
;;;153    						if (received == EOL) {
00002e  2c0d              CMP      r4,#0xd
000030  d12d              BNE      |L3.142|
;;;154    								usart_buf[usart_buf_length-1] = '\0';
000032  2100              MOVS     r1,#0
000034  1e68              SUBS     r0,r5,#1
000036  4a1d              LDR      r2,|L3.172|
000038  5411              STRB     r1,[r2,r0]
;;;155    								Usart_Send_Newline();
00003a  f7fffffe          BL       Usart_Send_Newline
;;;156    								if (strcmp(usart_buf, "LED 13 ON") == 0) status=1;
00003e  a11c              ADR      r1,|L3.176|
000040  481a              LDR      r0,|L3.172|
000042  f7fffffe          BL       strcmp
000046  b918              CBNZ     r0,|L3.80|
000048  2001              MOVS     r0,#1
00004a  491c              LDR      r1,|L3.188|
00004c  6008              STR      r0,[r1,#0]  ; status
00004e  e01d              B        |L3.140|
                  |L3.80|
;;;157    								else if (strcmp(usart_buf, "LED 13 OFF") == 0) status=2;
000050  a11b              ADR      r1,|L3.192|
000052  4816              LDR      r0,|L3.172|
000054  f7fffffe          BL       strcmp
000058  b918              CBNZ     r0,|L3.98|
00005a  2002              MOVS     r0,#2
00005c  4917              LDR      r1,|L3.188|
00005e  6008              STR      r0,[r1,#0]  ; status
000060  e014              B        |L3.140|
                  |L3.98|
;;;158    								else if (strcmp(usart_buf, "LED 14 ON") == 0) status=3;
000062  a11a              ADR      r1,|L3.204|
000064  4811              LDR      r0,|L3.172|
000066  f7fffffe          BL       strcmp
00006a  b918              CBNZ     r0,|L3.116|
00006c  2003              MOVS     r0,#3
00006e  4913              LDR      r1,|L3.188|
000070  6008              STR      r0,[r1,#0]  ; status
000072  e00b              B        |L3.140|
                  |L3.116|
;;;159    								else if (strcmp(usart_buf, "LED 14 OFF") == 0) status=4;
000074  a118              ADR      r1,|L3.216|
000076  480d              LDR      r0,|L3.172|
000078  f7fffffe          BL       strcmp
00007c  b918              CBNZ     r0,|L3.134|
00007e  2004              MOVS     r0,#4
000080  490e              LDR      r1,|L3.188|
000082  6008              STR      r0,[r1,#0]  ; status
000084  e002              B        |L3.140|
                  |L3.134|
;;;160    								else status = 5;
000086  2005              MOVS     r0,#5
000088  490c              LDR      r1,|L3.188|
00008a  6008              STR      r0,[r1,#0]  ; status
                  |L3.140|
;;;161    								usart_buf_length = 0;
00008c  2500              MOVS     r5,#0
                  |L3.142|
;;;162    						}
;;;163    						if (usart_buf_length == COMMAND_MAX_LENGTH) {
00008e  2d0f              CMP      r5,#0xf
000090  d105              BNE      |L3.158|
;;;164    								status = 6;
000092  2006              MOVS     r0,#6
000094  4909              LDR      r1,|L3.188|
000096  6008              STR      r0,[r1,#0]  ; status
;;;165    								Usart_Send_Newline();
000098  f7fffffe          BL       Usart_Send_Newline
;;;166    								usart_buf_length = 0;
00009c  2500              MOVS     r5,#0
                  |L3.158|
;;;167    						}
;;;168    				}
;;;169    				tx_thread_sleep(1);
00009e  2001              MOVS     r0,#1
0000a0  f7fffffe          BL       _tx_thread_sleep
                  |L3.164|
0000a4  e7ae              B        |L3.4|
;;;170    		}
;;;171    }
;;;172    /* Create thread */
                          ENDP

0000a6  0000              DCW      0x0000
                  |L3.168|
                          DCD      0x40013800
                  |L3.172|
                          DCD      usart_buf
                  |L3.176|
0000b0  4c454420          DCB      "LED 13 ON",0
0000b4  3133204f
0000b8  4e00    
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L3.188|
                          DCD      status
                  |L3.192|
0000c0  4c454420          DCB      "LED 13 OFF",0
0000c4  3133204f
0000c8  464600  
0000cb  00                DCB      0
                  |L3.204|
0000cc  4c454420          DCB      "LED 14 ON",0
0000d0  3134204f
0000d4  4e00    
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L3.216|
0000d8  4c454420          DCB      "LED 14 OFF",0
0000dc  3134204f
0000e0  464600  
0000e3  00                DCB      0

                          AREA ||i.Turn_Off_Led_13||, CODE, READONLY, ALIGN=2

                  Turn_Off_Led_13 PROC
;;;39     
;;;40     void Turn_Off_Led_13(void) {
000000  4803              LDR      r0,|L4.16|
;;;41         GPIOC->ODR &= ~GPIO_ODR_ODR13;
000002  68c0              LDR      r0,[r0,#0xc]
000004  f4205000          BIC      r0,r0,#0x2000
000008  4901              LDR      r1,|L4.16|
00000a  60c8              STR      r0,[r1,#0xc]
;;;42     }
00000c  4770              BX       lr
;;;43     void Turn_On_Led_14(void) {
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0x40011000

                          AREA ||i.Turn_Off_Led_14||, CODE, READONLY, ALIGN=2

                  Turn_Off_Led_14 PROC
;;;46     
;;;47     void Turn_Off_Led_14(void) {
000000  4803              LDR      r0,|L5.16|
;;;48         GPIOC->ODR &= ~GPIO_ODR_ODR14;
000002  68c0              LDR      r0,[r0,#0xc]
000004  f4204080          BIC      r0,r0,#0x4000
000008  4901              LDR      r1,|L5.16|
00000a  60c8              STR      r0,[r1,#0xc]
;;;49     }
00000c  4770              BX       lr
;;;50     void Usart_Init() {
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0x40011000

                          AREA ||i.Turn_On_Led_13||, CODE, READONLY, ALIGN=2

                  Turn_On_Led_13 PROC
;;;35     
;;;36     void Turn_On_Led_13(void) {
000000  4803              LDR      r0,|L6.16|
;;;37         GPIOC->ODR |= GPIO_ODR_ODR13;
000002  68c0              LDR      r0,[r0,#0xc]
000004  f4405000          ORR      r0,r0,#0x2000
000008  4901              LDR      r1,|L6.16|
00000a  60c8              STR      r0,[r1,#0xc]
;;;38     }
00000c  4770              BX       lr
;;;39     
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      0x40011000

                          AREA ||i.Turn_On_Led_14||, CODE, READONLY, ALIGN=2

                  Turn_On_Led_14 PROC
;;;42     }
;;;43     void Turn_On_Led_14(void) {
000000  4803              LDR      r0,|L7.16|
;;;44         GPIOC->ODR |= GPIO_ODR_ODR14;
000002  68c0              LDR      r0,[r0,#0xc]
000004  f4404080          ORR      r0,r0,#0x4000
000008  4901              LDR      r1,|L7.16|
00000a  60c8              STR      r0,[r1,#0xc]
;;;45     }
00000c  4770              BX       lr
;;;46     
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      0x40011000

                          AREA ||i.Usart_Init||, CODE, READONLY, ALIGN=2

                  Usart_Init PROC
;;;49     }
;;;50     void Usart_Init() {
000000  b500              PUSH     {lr}
000002  b085              SUB      sp,sp,#0x14
;;;51         GPIO_InitTypeDef GPIO_Settings;
;;;52         USART_InitTypeDef USART_Settings;
;;;53     
;;;54     		/* Enable clock USART and GPIOA */
;;;55         RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
000004  2101              MOVS     r1,#1
000006  0388              LSLS     r0,r1,#14
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;56         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  2004              MOVS     r0,#4
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;57     	
;;;58     		/* PA9 Tx */
;;;59         GPIO_StructInit(&GPIO_Settings);
000014  a804              ADD      r0,sp,#0x10
000016  f7fffffe          BL       GPIO_StructInit
;;;60         GPIO_Settings.GPIO_Pin = GPIO_Pin_9;
00001a  f44f7000          MOV      r0,#0x200
00001e  f8ad0010          STRH     r0,[sp,#0x10]
;;;61         GPIO_Settings.GPIO_Mode = GPIO_Mode_AF_PP;
000022  2018              MOVS     r0,#0x18
000024  f88d0013          STRB     r0,[sp,#0x13]
;;;62         GPIO_Settings.GPIO_Speed = GPIO_Speed_2MHz;
000028  2002              MOVS     r0,#2
00002a  f88d0012          STRB     r0,[sp,#0x12]
;;;63         GPIO_Init(GPIOA , &GPIO_Settings);
00002e  a904              ADD      r1,sp,#0x10
000030  4819              LDR      r0,|L8.152|
000032  f7fffffe          BL       GPIO_Init
;;;64     		
;;;65     		/* PA10 Rx*/
;;;66         GPIO_Settings.GPIO_Pin = GPIO_Pin_10;
000036  f44f6080          MOV      r0,#0x400
00003a  f8ad0010          STRH     r0,[sp,#0x10]
;;;67         GPIO_Settings.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003e  2004              MOVS     r0,#4
000040  f88d0013          STRB     r0,[sp,#0x13]
;;;68         GPIO_Settings.GPIO_Speed = GPIO_Speed_2MHz;
000044  2002              MOVS     r0,#2
000046  f88d0012          STRB     r0,[sp,#0x12]
;;;69         GPIO_Init(GPIOA , &GPIO_Settings);
00004a  a904              ADD      r1,sp,#0x10
00004c  4812              LDR      r0,|L8.152|
00004e  f7fffffe          BL       GPIO_Init
;;;70     
;;;71         USART_StructInit(&USART_Settings);
000052  4668              MOV      r0,sp
000054  f7fffffe          BL       USART_StructInit
;;;72         USART_Settings.USART_BaudRate = 9600;		/* Baud rate 9600 */
000058  f44f5016          MOV      r0,#0x2580
00005c  9000              STR      r0,[sp,#0]
;;;73         USART_Settings.USART_WordLength = USART_WordLength_8b;		/* 8bit data */	
00005e  2000              MOVS     r0,#0
000060  f8ad0004          STRH     r0,[sp,#4]
;;;74         USART_Settings.USART_StopBits = USART_StopBits_1;		/* 1 stop bit */
000064  f8ad0006          STRH     r0,[sp,#6]
;;;75         USART_Settings.USART_Parity = USART_Parity_No;		/* No parity */
000068  f8ad0008          STRH     r0,[sp,#8]
;;;76         USART_Settings.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00006c  f8ad000c          STRH     r0,[sp,#0xc]
;;;77         USART_Settings.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000070  200c              MOVS     r0,#0xc
000072  f8ad000a          STRH     r0,[sp,#0xa]
;;;78         USART_Init(USART1, &USART_Settings);
000076  4669              MOV      r1,sp
000078  4808              LDR      r0,|L8.156|
00007a  f7fffffe          BL       USART_Init
;;;79     
;;;80     		USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
00007e  2201              MOVS     r2,#1
000080  f2405125          MOV      r1,#0x525
000084  4805              LDR      r0,|L8.156|
000086  f7fffffe          BL       USART_ITConfig
;;;81     		USART_Cmd(USART1, ENABLE);
00008a  2101              MOVS     r1,#1
00008c  4803              LDR      r0,|L8.156|
00008e  f7fffffe          BL       USART_Cmd
;;;82     }
000092  b005              ADD      sp,sp,#0x14
000094  bd00              POP      {pc}
;;;83     
                          ENDP

000096  0000              DCW      0x0000
                  |L8.152|
                          DCD      0x40010800
                  |L8.156|
                          DCD      0x40013800

                          AREA ||i.Usart_Send||, CODE, READONLY, ALIGN=2

                  Usart_Send PROC
;;;84     /* Send one byte through USART */
;;;85     void Usart_Send(const char chr) {
000000  bf00              NOP      
                  |L9.2|
;;;86         while(!(USART1->SR & USART_SR_TC));
000002  4905              LDR      r1,|L9.24|
000004  8809              LDRH     r1,[r1,#0]
000006  f0010140          AND      r1,r1,#0x40
00000a  2900              CMP      r1,#0
00000c  d0f9              BEQ      |L9.2|
;;;87         USART1->DR = chr;
00000e  4902              LDR      r1,|L9.24|
000010  1d09              ADDS     r1,r1,#4
000012  8008              STRH     r0,[r1,#0]
;;;88     }
000014  4770              BX       lr
;;;89     
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      0x40013800

                          AREA ||i.Usart_Send_Line||, CODE, READONLY, ALIGN=2

                  Usart_Send_Line PROC
;;;102    
;;;103    void Usart_Send_Line(const char *s) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;104        Usart_Send_String(s);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       Usart_Send_String
;;;105        Usart_Send_String(CRLF);
00000a  a002              ADR      r0,|L10.20|
00000c  f7fffffe          BL       Usart_Send_String
;;;106    }
000010  bd10              POP      {r4,pc}
;;;107    
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
000014  0d0a00            DCB      "\r\n",0
000017  00                DCB      0

                          AREA ||i.Usart_Send_Newline||, CODE, READONLY, ALIGN=2

                  Usart_Send_Newline PROC
;;;98     /* Go to new line */
;;;99     void Usart_Send_Newline(void) {
000000  b500              PUSH     {lr}
;;;100        Usart_Send_String(CRLF);
000002  a002              ADR      r0,|L11.12|
000004  f7fffffe          BL       Usart_Send_String
;;;101    }
000008  bd00              POP      {pc}
;;;102    
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
00000c  0d0a00            DCB      "\r\n",0
00000f  00                DCB      0

                          AREA ||i.Usart_Send_String||, CODE, READONLY, ALIGN=1

                  Usart_Send_String PROC
;;;90     /* Send a string through USART */
;;;91     void Usart_Send_String(const char *s) {
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
;;;92         int i=0;
000004  2300              MOVS     r3,#0
;;;93         while (s[i]) {
000006  e004              B        |L12.18|
                  |L12.8|
;;;94             Usart_Send(s[i++]);
000008  4619              MOV      r1,r3
00000a  1c5b              ADDS     r3,r3,#1
00000c  5c50              LDRB     r0,[r2,r1]
00000e  f7fffffe          BL       Usart_Send
                  |L12.18|
000012  5cd0              LDRB     r0,[r2,r3]            ;93
000014  2800              CMP      r0,#0                 ;93
000016  d1f7              BNE      |L12.8|
;;;95         }
;;;96     }
000018  bd10              POP      {r4,pc}
;;;97     
                          ENDP


                          AREA ||i._tx_thread_system_return_inline||, CODE, READONLY, ALIGN=2

                  _tx_thread_system_return_inline PROC
;;;660    
;;;661    static void _tx_thread_system_return_inline(void)
000000  f04f5180          MOV      r1,#0x10000000
;;;662    {
;;;663    unsigned int interrupt_save;
;;;664    
;;;665        /* Set PendSV to invoke ThreadX scheduler.  */
;;;666        *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
000004  4a06              LDR      r2,|L13.32|
000006  6011              STR      r1,[r2,#0]
;;;667        if (_ipsr == 0)
000008  f3ef8105          MRS      r1,IPSR
00000c  b939              CBNZ     r1,|L13.30|
;;;668        {
;;;669    #ifdef TX_PORT_USE_BASEPRI
;;;670            interrupt_save = __get_interrupt_posture();
;;;671            __set_basepri_value(0);
;;;672            __set_basepri_value(interrupt_save);
;;;673    #else
;;;674            interrupt_save = __disable_irq();
00000e  f3ef8110          MRS      r1,PRIMASK
000012  f0010001          AND      r0,r1,#1
000016  b672              CPSID    i
;;;675            __enable_irq();
000018  b662              CPSIE    i
;;;676            if (interrupt_save != 0)
00001a  b100              CBZ      r0,|L13.30|
;;;677                __disable_irq();
00001c  b672              CPSID    i
                  |L13.30|
;;;678    #endif
;;;679        }
;;;680    }
00001e  4770              BX       lr
;;;681    
                          ENDP

                  |L13.32|
                          DCD      0xe000ed04

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;179    
;;;180    int main(void) {
000000  b510              PUSH     {r4,lr}
;;;181        /* Init output ports */
;;;182        Init_Output();
000002  f7fffffe          BL       Init_Output
;;;183        /* Init USART */
;;;184        Usart_Init();
000006  f7fffffe          BL       Usart_Init
;;;185    		/* Enter kernel */ 
;;;186    		tx_kernel_enter();
00000a  f7fffffe          BL       _tx_initialize_kernel_enter
;;;187     
;;;188    }
00000e  2000              MOVS     r0,#0
000010  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.tx_application_define||, CODE, READONLY, ALIGN=2

                  tx_application_define PROC
;;;172    /* Create thread */
;;;173    void tx_application_define(void *first_unused_memory) {
000000  b510              PUSH     {r4,lr}
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;174    		tx_thread_create(&Uart, "ReceiveCMD", Receive_Commmand, 0, 
000006  20b4              MOVS     r0,#0xb4
000008  2101              MOVS     r1,#1
00000a  2308              MOVS     r3,#8
00000c  e9cd3103          STRD     r3,r1,[sp,#0xc]
000010  e9cd1005          STRD     r1,r0,[sp,#0x14]
000014  02c9              LSLS     r1,r1,#11
000016  4a0f              LDR      r2,|L15.84|
000018  e9cd1301          STRD     r1,r3,[sp,#4]
00001c  9200              STR      r2,[sp,#0]
00001e  2300              MOVS     r3,#0
000020  4a0d              LDR      r2,|L15.88|
000022  a10e              ADR      r1,|L15.92|
000024  4810              LDR      r0,|L15.104|
000026  f7fffffe          BL       _txe_thread_create
;;;175    				uart_stack, STACK_SIZE, 8, 8, 1, TX_AUTO_START);
;;;176    		tx_thread_create(&Handle, "HandleCMD", Handle_Command, 0,
00002a  20b4              MOVS     r0,#0xb4
00002c  2101              MOVS     r1,#1
00002e  2310              MOVS     r3,#0x10
000030  e9cd3103          STRD     r3,r1,[sp,#0xc]
000034  e9cd1005          STRD     r1,r0,[sp,#0x14]
000038  02c9              LSLS     r1,r1,#11
00003a  4a0c              LDR      r2,|L15.108|
00003c  e9cd1301          STRD     r1,r3,[sp,#4]
000040  9200              STR      r2,[sp,#0]
000042  2300              MOVS     r3,#0
000044  4a0a              LDR      r2,|L15.112|
000046  a10b              ADR      r1,|L15.116|
000048  480d              LDR      r0,|L15.128|
00004a  f7fffffe          BL       _txe_thread_create
;;;177    				handle_stack, STACK_SIZE, 16, 16, 1, TX_AUTO_START);
;;;178    }
00004e  b008              ADD      sp,sp,#0x20
000050  bd10              POP      {r4,pc}
;;;179    
                          ENDP

000052  0000              DCW      0x0000
                  |L15.84|
                          DCD      uart_stack
                  |L15.88|
                          DCD      Receive_Commmand
                  |L15.92|
00005c  52656365          DCB      "ReceiveCMD",0
000060  69766543
000064  4d4400  
000067  00                DCB      0
                  |L15.104|
                          DCD      Uart
                  |L15.108|
                          DCD      handle_stack
                  |L15.112|
                          DCD      Handle_Command
                  |L15.116|
000074  48616e64          DCB      "HandleCMD",0
000078  6c65434d
00007c  4400    
00007e  00                DCB      0
00007f  00                DCB      0
                  |L15.128|
                          DCD      Handle

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Uart
                          %        180
                  Handle
                          %        180
                  uart_stack
                          %        2048
                  handle_stack
                          %        2048
                  usart_buf
                          %        15

                          AREA ||.data||, DATA, ALIGN=2

                  status
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_status____REV16|
#line 208 "C:\\Users\\Admin\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___6_main_c_status____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_status____REVSH|
#line 223
|__asm___6_main_c_status____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_status____RRX|
#line 410
|__asm___6_main_c_status____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
